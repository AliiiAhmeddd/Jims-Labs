// Represents the Patient domain model used throughout the app.
// This is not tied to Room database directly—Clean Architecture keeps domain independent.
package com.yourcompany.healthapp.domain.model

import java.time.LocalDate

data class Patient(
    val id: Long? = null,           // ID auto-generated by Room, null when creating a new patient
    val nhsNumber: String,          // Required NHS Number (validated before saving)
    val fullName: String,           // Patient’s full legal name
    val dateOfBirth: LocalDate,     // Patient DOB as LocalDate for accuracy
    val phoneNumber: String?,       // Optional phone number, may be null
    val email: String?              // Optional email, may be null
)

// Defines the repository interface for patient data operations.
// Clean Architecture: UI interacts with this, not Room directly.
package com.yourcompany.healthapp.domain.repository

import com.yourcompany.healthapp.domain.model.Patient

interface PatientRepository {
    // Registers a patient and returns a Result<Unit> containing success or error.
    suspend fun registerPatient(patient: Patient): Result<Unit>
}

// Room database entity mapping to the SQLite table "patients".
// Represents how the Patient object is stored internally on device.

package com.yourcompany.healthapp.data.local

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "patients")
data class PatientEntity(
    @PrimaryKey(autoGenerate = true) val id: Long = 0L, // Room auto-generates unique ID
    val nhsNumber: String,                                 // Stored as plain string
    val fullName: String,
    val dateOfBirth: String,  // Stored as ISO-8601 string (yyyy-MM-dd) for simplicity
    val phoneNumber: String?,
    val email: String?
)

// Data Access Object for performing database operations.
// Provides insert and future query/update functions.

package com.yourcompany.healthapp.data.local

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy

@Dao
interface PatientDao {

    // Inserts a patient record. ABORT stops duplicates without overwriting.
    @Insert(onConflict = OnConflictStrategy.ABORT)
    suspend fun insertPatient(patient: PatientEntity)
}

// Room database definition. Provides singleton access across the application.

package com.yourcompany.healthapp.data.local

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase

@Database(
    entities = [PatientEntity::class], // Register entity tables here
    version = 1,
    exportSchema = false
)
abstract class PatientDatabase : RoomDatabase() {

    abstract fun patientDao(): PatientDao // Exposes DAO to repository layer

    companion object {
        @Volatile
        private var INSTANCE: PatientDatabase? = null // Ensures only one instance exists

        fun getInstance(context: Context): PatientDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance =
                    Room.databaseBuilder(
                        context.applicationContext,
                        PatientDatabase::class.java,
                        "patient_db" // Database file name
                    )
                        // Hook for enabling SQLCipher encryption
                        // .openHelperFactory(EncryptedFactory(...))
                        .build()
                INSTANCE = instance
                instance
            }
        }
    }
}

// Repository implementation that converts domain model objects
// to database entities and executes Room operations.

package com.yourcompany.healthapp.data.repository

import com.yourcompany.healthapp.data.local.PatientDao
import com.yourcompany.healthapp.data.local.PatientEntity
import com.yourcompany.healthapp.domain.model.Patient
import com.yourcompany.healthapp.domain.repository.PatientRepository
import java.time.format.DateTimeFormatter

class PatientRepositoryImpl(
    private val patientDao: PatientDao  // DAO injected for DB operations
) : PatientRepository {

    private val formatter = DateTimeFormatter.ISO_LOCAL_DATE

    override suspend fun registerPatient(patient: Patient): Result<Unit> {
        return try {
            // Convert domain model to Room entity before saving
            val entity = PatientEntity(
                nhsNumber = patient.nhsNumber,
                fullName = patient.fullName,
                dateOfBirth = patient.dateOfBirth.format(formatter),
                phoneNumber = patient.phoneNumber,
                email = patient.email
            )
            patientDao.insertPatient(entity)
            Result.success(Unit) // Indicates success
        } catch (e: Exception) {
            Result.failure(e) // Return error
        }
    }
}

// Contains validation logic.
// Keeping validation standalone allows unit testing and reusability.

package com.yourcompany.healthapp.ui.registration

import android.util.Patterns

/**
 * NHS 10-digit checksum validation using mod 11 rule.
 */
fun isValidNhsNumber(input: String): Boolean {
    val nhs = input.replace(" ", "")         // Remove spaces for flexibility
    if (nhs.length != 10 || nhs.any { !it.isDigit() }) return false

    val digits = nhs.map { it.digitToInt() }
    val checkDigit = digits[9]               // Last digit is checksum

    var sum = 0
    for (i in 0 until 9) {                   // Weighted calculation
        val weight = 10 - i
        sum += digits[i] * weight
    }

    val remainder = sum % 11
    val expectedCheck = (11 - remainder).let { if (it == 11) 0 else it }

    if (expectedCheck == 10) return false   // NHS rule: check digit cannot be 10

    return checkDigit == expectedCheck
}

fun isValidName(name: String): Boolean =
    name.trim().length >= 2 // Simple length rule

fun isValidPhone(phone: String): Boolean =
    phone.isBlank() || phone.length in 7..20 // Optional field with length check

fun isValidEmail(email: String): Boolean =
    email.isBlank() || Patterns.EMAIL_ADDRESS.matcher(email).matches()

// Represents all UI fields, errors, and UX feedback states.

package com.yourcompany.healthapp.ui.registration

import java.time.LocalDate

data class RegistrationState(
    val nhsNumber: String = "",         // Input NHS number
    val fullName: String = "",          // Input Name
    val dateOfBirth: LocalDate? = null, // Must not be null to submit
    val phoneNumber: String = "",       // Optional
    val email: String = "",             // Optional

    // Per-field validation messages shown under each input
    val nhsError: String? = null,
    val nameError: String? = null,
    val dobError: String? = null,
    val phoneError: String? = null,
    val emailError: String? = null,

    val isSubmitting: Boolean = false,  // Shows loading spinner
    val submitError: String? = null,    // Display on snackbar
    val submitSuccess: Boolean = false  // Trigger success feedback
)

// Represents user actions from the screen (typing, changing etc.)
// ViewModel reads these events and updates state.

package com.yourcompany.healthapp.ui.registration

import java.time.LocalDate

sealed class RegistrationEvent {
    data class NhsChanged(val value: String) : RegistrationEvent()
    data class NameChanged(val value: String) : RegistrationEvent()
    data class DobChanged(val value: LocalDate) : RegistrationEvent()
    data class PhoneChanged(val value: String) : RegistrationEvent()
    data class EmailChanged(val value: String) : RegistrationEvent()
    object Submit : RegistrationEvent() // When user taps "Register"
}

// Handles UI logic, validation, updating state, and calling the repository.

package com.yourcompany.healthapp.ui.registration

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.yourcompany.healthapp.domain.model.Patient
import com.yourcompany.healthapp.domain.repository.PatientRepository
import java.time.LocalDate
import kotlinx.coroutines.launch

class RegistrationViewModel(
    private val repository: PatientRepository // Inject repository for data saving
) : ViewModel() {

    var state = RegistrationState()
        private set // External UI cannot modify state directly

    fun onEvent(event: RegistrationEvent) {
        // Update state when each input changes
        when (event) {
            is RegistrationEvent.NhsChanged -> {
                state = state.copy(
                    nhsNumber = event.value,
                    nhsError = null, // Clear previous error
                    submitError = null,
                    submitSuccess = false
                )
            }
            is RegistrationEvent.NameChanged -> {
                state = state.copy(
                    fullName = event.value,
                    nameError = null,
                    submitError = null,
                    submitSuccess = false
                )
            }
            is RegistrationEvent.DobChanged -> {
                state = state.copy(
                    dateOfBirth = event.value,
                    dobError = null,
                    submitError = null,
                    submitSuccess = false
                )
            }
            is RegistrationEvent.PhoneChanged -> {
                state = state.copy(
                    phoneNumber = event.value,
                    phoneError = null,
                    submitError = null,
                    submitSuccess = false
                )
            }
            is RegistrationEvent.EmailChanged -> {
                state = state.copy(
                    email = event.value,
                    emailError = null,
                    submitError = null,
                    submitSuccess = false
                )
            }
            RegistrationEvent.Submit -> submit()
        }
    }

    private fun submit() {
        // Extract values
        val nhs = state.nhsNumber
        val name = state.fullName
        val dob = state.dateOfBirth
        val phone = state.phoneNumber
        val email = state.email

        // Flag for validation failures
        var hasError = false

        // Validate inputs
        val nhsError = if (!isValidNhsNumber(nhs)) {
            hasError = true
            "Invalid NHS number"
        } else null

        val nameError = if (!isValidName(name)) {
            hasError = true
            "Please enter a full name"
        } else null

        val dobError = if (dob == null || dob.isAfter(LocalDate.now())) {
            hasError = true
            "Please select a valid date of birth"
        } else null

        val phoneError = if (!isValidPhone(phone)) {
            hasError = true
            "Invalid phone number"
        } else null

        val emailError = if (!isValidEmail(email)) {
            hasError = true
            "Invalid email address"
        } else null

        // Update UI with validation results
        state = state.copy(
            nhsError = nhsError,
            nameError = nameError,
            dobError = dobError,
            phoneError = phoneError,
            emailError = emailError,
            submitError = null,
            submitSuccess = false
        )

        if (hasError) return // Stop submit if invalid input

        // Launch coroutine to add to DB
        viewModelScope.launch {
            state = state.copy(isSubmitting = true, submitError = null)

            val patient = Patient(
                nhsNumber = nhs.replace(" ", ""), // Remove spaces before saving
                fullName = name.trim(),
                dateOfBirth = dob!!,
                phoneNumber = phone.ifBlank { null },
                email = email.ifBlank { null }
            )

            val result = repository.registerPatient(patient)

            state = if (result.isSuccess) {
                state.copy(
                    isSubmitting = false,
                    submitSuccess = true // Trigger snackbar success
                )
            } else {
                state.copy(
                    isSubmitting = false,
                    submitError = "Failed to register patient. Please try again."
                )
            }
        }
    }
}

// ui/registration/RegistrationScreen.kt
package com.yourcompany.healthapp.ui.registration

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Button
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import java.time.LocalDate

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun RegistrationScreen(
    viewModel: RegistrationViewModel   // ViewModel injected from Activity/DI
) {
    // Read current state from the ViewModel (contains form fields + errors)
    val state = viewModel.state

    // SnackbarHostState manages messages for snackbars (success/error)
    val snackbarHostState = remember { SnackbarHostState() }

    // Side-effect that reacts to changes in submitSuccess / submitError.
    // When either changes, we show a snackbar.
    LaunchedEffect(state.submitSuccess, state.submitError) {
        when {
            state.submitSuccess -> {
                snackbarHostState.showSnackbar("Patient registered successfully")
            }
            state.submitError != null -> {
                snackbarHostState.showSnackbar(state.submitError!!)
            }
        }
    }

    // Scaffold provides basic screen structure: top bar, content, snackbar, etc.
    Scaffold(
        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)              // Respect Scaffold insets
                .padding(16.dp)                // Standard screen padding
                .fillMaxSize()
                .verticalScroll(rememberScrollState()), // Scrollable for smaller screens
            verticalArrangement = Arrangement.Top,
            horizontalAlignment = Alignment.Start
        ) {
            // Screen title
            Text(
                text = "Patient Registration",
                style = MaterialTheme.typography.headlineMedium
            )

            Spacer(modifier = Modifier.height(16.dp))

            // NHS Number input field
            OutlinedTextField(
                value = state.nhsNumber,
                onValueChange = { viewModel.onEvent(RegistrationEvent.NhsChanged(it)) },
                label = { Text("NHS Number") },
                placeholder = { Text("10-digit NHS number") },
                isError = state.nhsError != null, // Display red outline on error
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                singleLine = true,
                modifier = Modifier.fillMaxWidth()
            )
            // Show NHS error text if present
            state.nhsError?.let {
                Text(text = it, color = MaterialTheme.colorScheme.error)
            }

            Spacer(modifier = Modifier.height(8.dp))

            // Full name input field
            OutlinedTextField(
                value = state.fullName,
                onValueChange = { viewModel.onEvent(RegistrationEvent.NameChanged(it)) },
                label = { Text("Full Name") },
                isError = state.nameError != null,
                singleLine = true,
                modifier = Modifier.fillMaxWidth()
            )
            // Show name error text if present
            state.nameError?.let {
                Text(text = it, color = MaterialTheme.colorScheme.error)
            }

            Spacer(modifier = Modifier.height(8.dp))

            // For simplicity, DOB is entered as plain text in yyyy-MM-dd format.
            // In a real app, you'd probably use a date picker instead.
            val dobText = state.dateOfBirth?.toString() ?: ""
            OutlinedTextField(
                value = dobText,
                onValueChange = { raw ->
                    // Try to parse the text into a LocalDate. If parsing fails,
                    // we ignore the change (keeps last valid date).
                    val parsed = runCatching { LocalDate.parse(raw) }.getOrNull()
                    if (parsed != null) {
                        viewModel.onEvent(RegistrationEvent.DobChanged(parsed))
                    }
                },
                label = { Text("Date of Birth (yyyy-MM-dd)") },
                isError = state.dobError != null,
                singleLine = true,
                modifier = Modifier.fillMaxWidth()
            )
            // Show DOB error text if present
            state.dobError?.let {
                Text(text = it, color = MaterialTheme.colorScheme.error)
            }

            Spacer(modifier = Modifier.height(8.dp))

            // Phone number input field (optional)
            OutlinedTextField(
                value = state.phoneNumber,
                onValueChange = { viewModel.onEvent(RegistrationEvent.PhoneChanged(it)) },
                label = { Text("Phone Number (optional)") },
                isError = state.phoneError != null,
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone),
                singleLine = true,
                modifier = Modifier.fillMaxWidth()
            )
            // Show phone error text if present
            state.phoneError?.let {
                Text(text = it, color = MaterialTheme.colorScheme.error)
            }

            Spacer(modifier = Modifier.height(8.dp))

            // Email input field (optional)
            OutlinedTextField(
                value = state.email,
                onValueChange = { viewModel.onEvent(RegistrationEvent.EmailChanged(it)) },
                label = { Text("Email (optional)") },
                isError = state.emailError != null,
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
                singleLine = true,
                modifier = Modifier.fillMaxWidth()
            )
            // Show email error text if present
            state.emailError?.let {
                Text(text = it, color = MaterialTheme.colorScheme.error)
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Submit button
            Button(
                onClick = { viewModel.onEvent(RegistrationEvent.Submit) },
                enabled = !state.isSubmitting,          // Disabled while submitting
                modifier = Modifier.align(Alignment.End)
            ) {
                // Show a small loading spinner inside the button while submitting
                if (state.isSubmitting) {
                    CircularProgressIndicator(
                        modifier = Modifier
                            .size(20.dp)
                            .padding(end = 8.dp),
                        strokeWidth = 2.dp
                    )
                }
                Text(text = "Register")
            }
        }
    }
}

// ui/registration/ValidationTest.kt
package com.yourcompany.healthapp.ui.registration

import org.junit.Assert.*
import org.junit.Test

// Unit tests verify that the validation logic behaves as expected.
// These tests support the non-functional requirement for validation.

class ValidationTest {

    @Test
    fun `valid NHS number passes`() {
        // Example valid NHS number (should satisfy the checksum algorithm).
        // In a real scenario, ensure this number is truly valid as per NHS docs.
        val valid = "943 476 5919"
        assertTrue(isValidNhsNumber(valid))
    }

    @Test
    fun `invalid NHS number fails`() {
        // This is a random 10-digit number that should fail checksum validation.
        val invalid = "1234567890"
        assertFalse(isValidNhsNumber(invalid))
    }

    @Test
    fun `blank name fails`() {
        // Empty name strings should not be accepted.
        assertFalse(isValidName(""))
    }

    @Test
    fun `valid email passes and invalid fails`() {
        // Valid email format should pass.
        assertTrue(isValidEmail("test@example.com"))

        // Invalid format should fail.
        assertFalse(isValidEmail("not-an-email"))
    }
}
